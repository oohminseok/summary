#pragma once

//프로그램(Program): 컴퓨터에게 명령을 내려 순서대로 처리하는것
//소스코드(Source Code): 프로그래머가 작성한 코드를 소스코드라 하며 cpp,h와 같은 텍스트 파일
//목적코드(Object Code): 작성한 코드를 컴퓨터가 이해할수 있는 코드로 변경시킨 것 
//컴파일(Compile): 소스코드를 목적코드로 변환시키는 과정
//링크(Link): 컴파일후 생성된 목적코드들을 실행파일로 만드는 과정
//빌드(Buuld): 컴파일 과정과 링크 과정을 합친 것
//라이브러리(Library): 다른 프로그래머가 작성한 #include <iostream>에 포함된 기능을 사용할수 있게해주는 것
//IDE(integrated Developmnet Environment): 비쥬얼스튜디오 같은 개발환경도구
//함수(Function): 여러개의 명령어들을 모아놓고 사용하기 위해 이름을 붙여놓음
// main(): 프로그램 실행시 main함수에서 시작
//솔루션(Solution):여러개의 프로젝트를 관리하는 파일구조
//프로젝트(Project):앱을 빌드하기 위해 필요한 아이템을 모아둔것

----------------------------------------------------------------------------------------------------------------

//ASCII: 아스키코드->미국정보교환표준부호 128개의 문자들로 이루어져있음
//std::cout: charcter output stream 문자를 내보낸다
//std::cin: character input stream 문자를 입력받는다.
//변수(variable):값을 저장할수 있는 객체(object)에 이름을 붙임
//int:정수(-1,1,2,4,6,8.....)
//float:부동소수점(1.1f,2.3f,4.5f)
//bool:true, false 참 거짓
//char:문자(a,b,c,d...)
//Overflow(오버플로): 각 타입이 가지고 있는 범위를 넘어서면 최소값으로 변함
//Underflow(언더플로): 각 타입이 가지고 있는 범위보다 작아지면 최대값으로 변함
//선언: 이름을 붙인 객체에게 메모리가 사용할 공간을 할당

----------------------------------------------------------------------------------------------------------------

//인자:키보드,터치 스크린 프로그램의 입력들을 인자라고 한다.
//자료구조: 입력받은 인자들의 데이터를 묶어서 관리하는 것을 자료구조라고 한다. 
//표현식: expression 표현식은 연산자와 피연산자로 되어있다. ex)int length=20;
//Lexicon: 어휘 ex) int(정수 타입) a(변수명) =(연산자) 3(값)
//Syntax: 구문 ex) int a; 
//Semantic: 의미 ex) int a=3; 정수타입 a에 3을 대입한다.
//if구문: if(조건식) {}
//Flow Chart: 순서도
//전처리기 지시문: #include<> 컴파일 전에 먼저 가져와 포함시킨다.
//switch~csae 구문: switch(값){ case 상수1:...break; } 
//레이블(Lable): switch 구문에서 case를 레이블이라 한다.

----------------------------------------------------------------------------------------------------------------

//암시적 변환(Implicit Conversion): 컴파일러가 자동적으로 변환시켜준다.
//명시적 변환(Explixit Conversion): 프로그래머가 직접 형변환 해야한다.
//타입안전성(Type Safe): 타입에 따라 알맞은 값을 넣어야함
//축소변환(Narrow Conversion): int(4바이트)->char(1바이트)처럼 큰 것을 작은 것으로 변환하는 것을 말한다.
//오버플로(Overflow): 넘쳐흐르다는 뜻으로 배열의 크기를 지정했을시 그 크기를 넘어가면 오버플로가 발생한다.
//열거형(Enumeration Type): enum 타입{원소1,원소2...} 새로운 타입을 만든다.
//구조체(Structure):struct 형식이름{int,float,enum,char} 타입들을 묶은것 
//배열(Array): 동일한 형식의 타입으로 여러개 저장할수 있다.
//문자열(Character Array):문자타입(char)로 이루어진 집합
//왼쪽값(lvalue): 이름을 붙인 객체(변수)
//오른쪽값(rvalue): 이름이 없는 객체(상수,리터럴)

----------------------------------------------------------------------------------------------------------------

//함수 선언(function declaration): 반환타입 함수이름(매개변수타입 및 이름)로 선언한다.
//함수 정의(function defition): 함수 내부안에 명령어들의 집
//매개변수(parameter):함수를 호출할떄 인자에서 보낸 값을 사용할수 있게 해주는 변수이다.
//인자(argument):함수를 호출할때 값을 보내는 역할
//값에 의한 호출(Call By Value):함수를 호출할떄 인자의 값을 매개변수로 보낸다.
//함수 다형성(function polymorphism):함수의 형태가 다양하다는 뜻으로 오버로딩이라 볼수있다.
//함수 오버로딩(Function Overloading):반환타입 이름이 같으나 매개변수의 타입 및 이름이 다른 것을 함수의 오버로딩이라 한다.
//함수 시그니쳐(Function signature):함수의 이름 매개변수의 타입 개수 순서등을 시그니쳐라 볼수있다.
//프로그램 진입점(Program Entry Point): main()함수를 프로그램의 진입점이라 한다.
//재귀 함수(Recursive Function):함수 내부에서 자기자신을 다시 호출하는것을 재귀함수라 한다.
//스택(Stack):마지막에 들어온것을 먼저 꺼낸다는 의미(LIFO:Last In First Out)의 자료구조를 스택이라고 하며 함수의 진행과정을 호출스택이라고 한다.

----------------------------------------------------------------------------------------------------------------

//포인터(pointer):같은 타입을 가진 객체의 주소를 가르킨다.
//참조에 의한 호출(call by reference):함수를 호출할떄 매개변수가 인자의 값을 참조하는 것을 말한다.
//포인터 변수의 크기(sizeof pointer): 포인터 변수의 크기는 32bit의 경우 4바이트 64bit의 경우 8바이트 이다.
//화살표 연산자(Arrow operator):가르키는 타입의 값에 접근할떄 사용한다.
//참조형(Reference Type):같은 타입의 객체에 대한 값을 참조한다.
//동적 메모리 할당(Dynamic Memory Allocation):프로그램 실행동안 사용할 메모리공간을 프로그래머가 할당할수 있으며 해제할수 있다.
//함수 포인터(function Pointer): 함수 타입의 주소를 가르킨다. ex) int(*p)num(int x,int y)

----------------------------------------------------------------------------------------------------------------

//클래스(class):객체를 만들기 위한 설계도 또는 틀
//객체(object): 사물을 실제화 한것을 객체라고 하며 인스턴스라고도 불린다.
//인스턴스(instance): 객체랑 동일하다.
//접근 제한자(access modifieres):  public,private,protected를 사용한다.
//캡슐화(capulation): 객체의 상태와 행동을 묶어놓은 것
//정보 은닉(information hiding): 캡슐화된 정보들의 내부 데이터를 감춤
//범위 해결 연산자(scope resolution operator):  "클래스이름"::함수명 또는 변수명 으로 표기한다.
//상수 멤버 함수(const member function): 상수 멤버함수는 멤버변수의 값을 변경할수 없다.
//this 포인터: this는 객체 자기자신이며 const이다
//속성(property):멤버 함수로 멤버변수의 값을 수정 getter(값 구해오기)/setter(값 지정하기) 라고도 부름
//생성자(constructor): 객체가 만들어지면 자동으로 호출되는 생성자가 불린다.
//소멸자(destructor): 객체가 소멸될떄 자동으로 소멸자가 불린다.
//유니폼 초기화(uniform initialize): 유니폼{} 처럼 생긴 형태로 형변환이 허용되지 않아 안전하다. 
//초기화 리스트(initialize list): 복사 초기화, 직접 초기화, 유니폼 초기화 ,유니폼 복사 초기화 등이 있다.
//class vs struct: 클래스의 경우 멤버함수와 멤버 변수를 사용,구조체도 클래스와 동일하게 멤버함수도 사용할수 있으나 멤버변수만 사용
//정적 멤버(static member): 클래스 내부에서만 사용 가능하면 클래스 변수라고도 불린다. 
//복사 생성자(copy constructor): 새로운 객체를 초기화 할떄 기존에 있던 객체의 데이터를 넘겨줄떄 불리는 생성자
//얕은 복사(swallow copy) vs 깊은 복사(deep copy): 얕은 복사의 경우 멤버 변수에 포인터가 있을경우 동적으로 생성한 데이터를 기존에 있던 객체와 동일하게 가르키므로 위험하다 그러므로 깊은 복사를 통해 새로 만드는 것이 안전하다. 
//연산자 오버로딩(operator overloading): +,-,+=,<<,++등 오버로딩을 통해 다양하게 적용할수 있다.
//상속(inheritance) or 파생(derivation):특징을 물려받는것
//기반클래스(base class) vs 파생 클래스(derived class): 기반클래스는 부모 파생클래스는 자식의 관계로 볼수 있다.
//오버라이딩(overriding):상속관계에서 부모의 함수 정의를 자식이 재정의 하는것
//다형성(polymorphism):다양한 형태로 해석된다는 뜻으로 자식이 어떨떄는 자기 자신으로 해석될수도 있고 부모로 해석될수도 있다.
//가상함수(virtual function): 부모의 함수를 자식이 재정의 할것으로 기대하는 것
//가상 소멸자(virtual destructor): 상속 관계에서 소멸자에 virtual를 붙여서 사용할 경우 부모의 소멸자를 자식이 재정의하는 것으로 기대하므로 자식의 소멸자가 먼저 불린다.
//upcast vs downcast: 파생클래스->기반클래스 상향변환이다. 기반클래스->파생클래스 하향변환이다. 
//static_cast: 정적변환 컴파일 시간에 결정
//dynamic_cast: 동적변환 런타임 시간에 결정
//순수 가상함수(pure virtual function):부모의 함수를 자식이 반드시 재정의 해야하는 것으로 만약 재정의를 하지 않을시 인스턴스를 생성할수 없다.
//추상 기반 클래스(abstract base class):순수 가상함수를 하나라도 가지고 있으면 추상기반클래스라고 부르며 인스턴스를 생성할수 없다.
//친구 클래스(friend class): 다른 클래스를 친구로 지정하실 친구로 지정된 클래스는 나의 정보를 볼수 있으나 나는 친구의 정보를 볼수 없다.
//친구 함수(friend function): 친구함수의 경우 멤버함수가 아니고 전역함수이다.
