#pragma once

//프로그램(Program): 컴퓨터에게 명령을 내려 순서대로 처리하는것
//소스코드(Source Code): 프로그래머가 작성한 코드를 소스코드라 하며 cpp,h와 같은 텍스트 파일
//목적코드(Object Code): 작성한 코드를 컴퓨터가 이해할수 있는 코드로 변경시킨 것 
//컴파일(Compile): 소스코드를 목적코드로 변환시키는 과정
//링크(Link): 컴파일후 생성된 목적코드들을 실행파일로 만드는 과정
//빌드(Buuld): 컴파일 과정과 링크 과정을 합친 것
//라이브러리(Library): 다른 프로그래머가 작성한 #include <iostream>에 포함된 기능을 사용할수 있게해주는 것
//IDE(integrated Developmnet Environment): 비쥬얼스튜디오 같은 개발환경도구
//함수(Function): 여러개의 명령어들을 모아놓고 사용하기 위해 이름을 붙여놓음
// main(): 프로그램 실행시 main함수에서 시작
//솔루션(Solution):여러개의 프로젝트를 관리하는 파일구조
//프로젝트(Project):앱을 빌드하기 위해 필요한 아이템을 모아둔것

----------------------------------------------------------------------------------------------------------------

//ASCII: 아스키코드->미국정보교환표준부호 128개의 문자들로 이루어져있음
//std::cout: charcter output stream 문자를 내보낸다
//std::cin: character input stream 문자를 입력받는다.
//변수(variable):값을 저장할수 있는 객체(object)에 이름을 붙임
//int:정수(-1,1,2,4,6,8.....)
//float:부동소수점(1.1f,2.3f,4.5f)
//bool:true, false 참 거짓
//char:문자(a,b,c,d...)
//Overflow(오버플로): 각 타입이 가지고 있는 범위를 넘어서면 최소값으로 변함
//Underflow(언더플로): 각 타입이 가지고 있는 범위보다 작아지면 최대값으로 변함
//선언: 이름을 붙인 객체에게 메모리가 사용할 공간을 할당
//lvalue: 피연산자 좌측값
//rvalue: 피연산자 우측값

----------------------------------------------------------------------------------------------------------------

//인자:키보드,터치 스크린 프로그램의 입력들을 인자라고 한다.
//자료구조: 입력받은 인자들의 데이터를 묶어서 관리하는 것을 자료구조라고 한다. 
//표현식: expression 표현식은 연산자와 피연산자로 되어있다. ex)int length=20;
//Lexicon: 어휘 ex) int(정수 타입) a(변수명) =(연산자) 3(값)
//Syntax: 구문 ex) int a; 
//Semantic: 의미 ex) int a=3; 정수타입 a에 3을 대입한다.
//if구문: if(조건식) {}
//Flow Chart: 순서도
//전처리기 지시문: #include<> 컴파일 전에 먼저 가져와 포함시킨다.
//switch~csae 구문: switch(값){ case 상수1:...break; } 
//레이블(Lable): switch 구문에서 case를 레이블이라 한다.

----------------------------------------------------------------------------------------------------------------

//클래스(class):객체를 만들기 위한 설계도 또는 틀
//객체(object): 사물을 실제화 한것을 객체라고 하며 인스턴스라고도 불린다.
//인스턴스(instance): 객체랑 동일하다.
//접근 제한자(access modifieres):  public,private,protected를 사용한다.
//캡슐화(capulation): 객체의 상태와 행동을 묶어놓은 것
//정보 은닉(information hiding): 캡슐화된 정보들의 내부 데이터를 감춤
//범위 해결 연산자(scope resolution operator):  "클래스이름"::함수명 또는 변수명 으로 표기한다.
//상수 멤버 함수(const member function): 상수 멤버함수는 멤버변수의 값을 변경할수 없다.
//this 포인터: this는 객체 자기자신이며 const이다
//속성(property):멤버 함수로 멤버변수의 값을 수정 getter(값 구해오기)/setter(값 지정하기) 라고도 부름
//생성자(constructor): 객체가 만들어지면 자동으로 호출되는 생성자가 불린다.
//소멸자(destructor): 객체가 소멸될떄 자동으로 소멸자가 불린다.
//유니폼 초기화(uniform initialize): 유니폼{} 처럼 생긴 형태로 형변환이 허용되지 않아 안전하다. 
//초기화 리스트(initialize list): 복사 초기화, 직접 초기화, 유니폼 초기화 ,유니폼 복사 초기화 등이 있다.
//class vs struct: 클래스의 경우 멤버함수와 멤버 변수를 사용,구조체도 클래스와 동일하게 멤버함수도 사용할수 있으나 멤버변수만 사용
//정적 멤버(static member): 클래스 내부에서만 사용 가능하면 클래스 변수라고도 불린다. 
//복사 생성자(copy constructor): 새로운 객체를 초기화 할떄 기존에 있던 객체의 데이터를 넘겨줄떄 불리는 생성자
//얕은 복사(swallow copy) vs 깊은 복사(deep copy): 얕은 복사의 경우 멤버 변수에 포인터가 있을경우 동적으로 생성한 데이터를 기존에 있던 객체와 동일하게 가르키므로 위험하다 그러므로 깊은 복사를 통해 새로 만드는 것이 안전하다. 
//연산자 오버로딩(operator overloading): +,-,+=,<<,++등 오버로딩을 통해 다양하게 적용할수 있다.
//상속(inheritance) or 파생(derivation):특징을 물려받는것
//기반클래스(base class) vs 파생 클래스(derived class): 기반클래스는 부모 파생클래스는 자식의 관계로 볼수 있다.
//오버라이딩(overriding):상속관계에서 부모의 함수 정의를 자식이 재정의 하는것
//다형성(polymorphism):다양한 형태로 해석된다는 뜻으로 자식이 어떨떄는 자기 자신으로 해석될수도 있고 부모로 해석될수도 있다.
//가상함수(virtual function): 부모의 함수를 자식이 재정의 할것으로 기대하는 것
//가상 소멸자(virtual destructor): 상속 관계에서 소멸자에 virtual를 붙여서 사용할 경우 부모의 소멸자를 자식이 재정의하는 것으로 기대하므로 자식의 소멸자가 먼저 불린다.
//upcast vs downcast: 파생클래스->기반클래스 상향변환이다. 기반클래스->파생클래스 하향변환이다. 
//static_cast: 정적변환 컴파일 시간에 결정
//dynamic_cast: 동적변환 런타임 시간에 결정
//순수 가상함수(pure virtual function):부모의 함수를 자식이 반드시 재정의 해야하는 것으로 만약 재정의를 하지 않을시 인스턴스를 생성할수 없다.
//추상 기반 클래스(abstract base class):순수 가상함수를 하나라도 가지고 있으면 추상기반클래스라고 부르며 인스턴스를 생성할수 없다.
//친구 클래스(friend class): 다른 클래스를 친구로 지정하실 친구로 지정된 클래스는 나의 정보를 볼수 있으나 나는 친구의 정보를 볼수 없다.
//친구 함수(friend function): 친구함수의 경우 멤버함수가 아니고 전역함수이다.
